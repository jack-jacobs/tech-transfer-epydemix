---
title: "Model Calibration with Epydemix"
subtitle: "Session 3 - Tutorial 2"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Prerequisites

This tutorial uses the `reticulate` package to call Epydemix (a Python package) from R.
Make sure you have:

1. Python with Epydemix installed (`pip install epydemix` or `conda install -c conda-forge epydemix`)
2. The `reticulate` R package (`install.packages("reticulate")`)

```{r load-reticulate}
library(reticulate)
py_require("epydemix")
library(readr)
library(ggplot2)
library(dplyr)

# Import epydemix modules
epydemix <- import("epydemix")
load_predefined_model <- epydemix$load_predefined_model
utils_module <- import("epydemix.utils")
compute_simulation_dates <- utils_module$compute_simulation_dates

# Import matplotlib for plot display
plt <- import("matplotlib.pyplot")
```

---

## 1. Loading and Exploring the Data

We'll calibrate an SIR model to synthetic incidence data (new infections per day) from North Carolina.

```{r load-data}
# Load the CSV directly from GitHub
data <- read_csv(
  "https://raw.githubusercontent.com/epistorm/tech-transfer-epydemix/refs/heads/main/sessions/session-3/data/incidence_data.csv",
  show_col_types = FALSE
)
data <- data %>% mutate(date = as.Date(date))

# Split into calibration and projection periods
n_total <- nrow(data)
n_calibration <- n_total - 70
data_calibration <- data[1:n_calibration, ]
data_projection <- data[(n_calibration + 1):n_total, ]

cat(sprintf("Calibration period: %s to %s (%d days)\n",
            data_calibration$date[1],
            data_calibration$date[nrow(data_calibration)],
            nrow(data_calibration)))
cat(sprintf("Projection period: %s to %s (%d days)\n",
            data_projection$date[1],
            data_projection$date[nrow(data_projection)],
            nrow(data_projection)))
```

```{r viz-data, fig.width=10, fig.height=4}
ggplot() +
  geom_point(data = data_calibration, aes(x = date, y = data), color = "black") +
  geom_point(data = data_projection, aes(x = date, y = data), color = "gray", alpha = 0.5) +
  geom_vline(xintercept = as.numeric(data_calibration$date[nrow(data_calibration)]),
             color = "red", linetype = "dashed", alpha = 0.5) +
  labs(x = "Date", y = "New Infections", title = "Incidence Data: Calibration vs Held-out") +
  theme_minimal()
```

---

## 2. Setting Up the Model

```{r setup-model}
# Load predefined SIR model
model <- load_predefined_model("SIR")
model$import_epydemix_population(population_name = "United_States_North_Carolina")
model
```

```{r setup-params}
# Get population size
Nk_r <- py_to_r(model$population$Nk)

# Initial conditions: 0.05% of population infected
infected <- as.integer(Nk_r * 0.05 / 100)
susceptible <- as.integer(Nk_r - infected)
recovered <- rep(0L, length(Nk_r))

initial_conditions <- reticulate::dict(
  Susceptible = susceptible,
  Infected = infected,
  Recovered = recovered
)

# Date strings
start_date_chr <- as.character(data_calibration$date[1])
end_date_calibration_chr <- as.character(data_calibration$date[nrow(data_calibration)])
end_date_projection_chr <- as.character(data_projection$date[nrow(data_projection)])

# Parameters dict for calibration
parameters <- reticulate::dict(
  initial_conditions_dict = initial_conditions,
  epimodel = model,
  start_date = start_date_chr,
  end_date = end_date_calibration_chr
)

# Compute simulation dates
simulation_dates_calibration <- compute_simulation_dates(
  start_date = start_date_chr,
  end_date = end_date_calibration_chr
)

simulation_dates_projection <- compute_simulation_dates(
  start_date = start_date_chr,
  end_date = end_date_projection_chr
)
```

---

## 3. Defining Priors and the Calibration Wrapper

### Prior Distributions

Prior distributions encode our beliefs about parameter values before seeing the data.

```{r define-priors}
# Import scipy.stats
scipy_stats <- import("scipy.stats")

# Uniform priors for transmission and recovery rates
priors <- reticulate::dict(
  transmission_rate = scipy_stats$uniform(loc = 0.010, scale = 0.020),  # U(0.01, 0.03)
  recovery_rate = scipy_stats$uniform(loc = 0.15, scale = 0.1)          # U(0.15, 0.25)
)
```

### Simulation Wrapper Function

The `ABCSampler` requires a function that returns a dictionary with a `'data'` key. We define this in Python since it needs to be callable by the calibration engine.

```{r define-wrapper}
# Import calibration module
calib <- import("epydemix.calibration")
ABCSampler <- calib$ABCSampler
rmse <- calib$rmse

# Define the wrapper function in Python
py_run_string("
from epydemix import simulate

def simulate_wrapper(parameters):
    results = simulate(**parameters)
    return {'data': results.transitions['Susceptible_to_Infected_total']}
")

simulate_wrapper <- py$simulate_wrapper

# Observed data
observed_data <- data_calibration$data

# Initialize the ABC sampler
abc_sampler <- ABCSampler(
  simulation_function = simulate_wrapper,
  priors = priors,
  parameters = parameters,
  observed_data = observed_data,
  distance_function = rmse
)
```

---

## 4. Running Calibration

Epydemix supports three calibration strategies:

| Method | Description | When to Use |
|--------|-------------|-------------|
| **ABC-SMC** | Sequential Monte Carlo with adaptive tolerance | Most accurate, recommended for final results |
| **ABC Rejection** | Simple accept/reject with fixed tolerance | Fast exploratory analysis |
| **Top X%** | Keep best fraction of simulations | Fixed runtime, good for prototyping |

```{r run-abc-smc}
# ABC-SMC: 5 generations, 100 particles
results_abc_smc <- abc_sampler$calibrate(
  strategy = "smc",
  num_particles = 100L,
  num_generations = 5L
)
```

```{r run-abc-rejection}
# ABC Rejection: fixed tolerance based on ABC-SMC final epsilon
results_abc_rejection <- abc_sampler$calibrate(
  strategy = "rejection",
  num_particles = 100L,
  epsilon = 17000
)
```

```{r run-top-perc}
# Top X%: keep best 10% of 1000 simulations
results_top_perc <- abc_sampler$calibrate(
  strategy = "top_fraction",
  Nsim = 1000L,
  top_fraction = 0.1
)
```

---

## 5. Comparing Calibration Results

### Calibration Fits

```{r viz-fits-setup}
# Import visualization functions
viz <- import("epydemix.visualization")
plot_quantiles <- viz$plot_quantiles

# Get quantiles for each method
df_quantiles_smc <- results_abc_smc$get_calibration_quantiles(dates = simulation_dates_calibration)
df_quantiles_rejection <- results_abc_rejection$get_calibration_quantiles(dates = simulation_dates_calibration)
df_quantiles_top <- results_top_perc$get_calibration_quantiles(dates = simulation_dates_calibration)
```

```{r viz-fits-smc}
# Plot ABC-SMC
plot_quantiles(df_quantiles_smc, columns = "data", data = data_calibration,
               title = "ABC-SMC", colors = "red", show_data = TRUE,
               labels = list("New Infections"))
plt$show()
```

```{r viz-fits-rejection}
# Plot ABC Rejection
plot_quantiles(df_quantiles_rejection, columns = "data", data = data_calibration,
               title = "ABC Rejection", colors = "blue", show_data = TRUE)
plt$show()
```

```{r viz-fits-top}
# Plot Top 10%
plot_quantiles(df_quantiles_top, columns = "data", data = data_calibration,
               title = "Top 10%", colors = "green", show_data = TRUE)
plt$show()
```

### Posterior Distributions

```{r viz-posterior-2d-smc}
plot_posterior_distribution_2d <- viz$plot_posterior_distribution_2d

# ABC-SMC posterior
plot_posterior_distribution_2d(
  results_abc_smc$get_posterior_distribution(),
  "transmission_rate", "recovery_rate",
  kind = "kde", title = "ABC-SMC", prior_range = FALSE
)
plt$show()
```

```{r viz-posterior-2d-rejection}
# ABC Rejection posterior
plot_posterior_distribution_2d(
  results_abc_rejection$get_posterior_distribution(),
  "transmission_rate", "recovery_rate",
  kind = "kde", title = "ABC Rejection", prior_range = FALSE
)
plt$show()
```

```{r viz-posterior-2d-top}
# Top 10% posterior
plot_posterior_distribution_2d(
  results_top_perc$get_posterior_distribution(),
  "transmission_rate", "recovery_rate",
  kind = "kde", title = "Top 10%", prior_range = FALSE
)
plt$show()
```

### Marginal Posteriors

```{r viz-marginal-transmission}
plot_posterior_distribution <- viz$plot_posterior_distribution

# Transmission rate
ax <- plot_posterior_distribution(
  results_abc_smc$get_posterior_distribution(), "transmission_rate",
  kind = "kde", color = "red", label = "ABC-SMC", prior_range = FALSE
)
ax <- plot_posterior_distribution(
  results_abc_rejection$get_posterior_distribution(), "transmission_rate",
  kind = "kde", color = "blue", label = "ABC Rejection", prior_range = FALSE, ax = ax
)
ax <- plot_posterior_distribution(
  results_top_perc$get_posterior_distribution(), "transmission_rate",
  kind = "kde", color = "green", label = "Top 10%", prior_range = FALSE, ax = ax
)
ax$set_title("Transmission Rate Posterior")
ax$legend()
plt$show()
```

```{r viz-marginal-recovery}
# Recovery rate
ax <- plot_posterior_distribution(
  results_abc_smc$get_posterior_distribution(), "recovery_rate",
  kind = "kde", color = "red", label = "ABC-SMC", prior_range = FALSE
)
ax <- plot_posterior_distribution(
  results_abc_rejection$get_posterior_distribution(), "recovery_rate",
  kind = "kde", color = "blue", label = "ABC Rejection", prior_range = FALSE, ax = ax
)
ax <- plot_posterior_distribution(
  results_top_perc$get_posterior_distribution(), "recovery_rate",
  kind = "kde", color = "green", label = "Top 10%", prior_range = FALSE, ax = ax
)
ax$set_title("Recovery Rate Posterior")
ax$legend()
plt$show()
```

### Distance Distributions

```{r viz-distance}
plot_distance_distribution <- viz$plot_distance_distribution

ax <- plot_distance_distribution(
  results_abc_smc$get_distances(),
  kind = "kde", color = "red", label = "ABC-SMC", xlabel = "RMSE"
)
ax <- plot_distance_distribution(
  results_abc_rejection$get_distances(),
  kind = "kde", color = "blue", label = "ABC Rejection", xlabel = "RMSE", ax = ax
)
ax <- plot_distance_distribution(
  results_top_perc$get_distances(),
  kind = "kde", color = "green", label = "Top 10%", xlabel = "RMSE", ax = ax
)
ax$set_title("Distribution of Distances for Accepted Particles")
ax$legend()
plt$show()
```

---

## 6. Running Projections

After calibrating, we project the epidemic forward using the posterior parameter samples.

```{r run-projections}
# Extend end date for projections
projection_parameters <- reticulate::dict(
  initial_conditions_dict = initial_conditions,
  epimodel = model,
  start_date = start_date_chr,
  end_date = end_date_projection_chr
)

# Run projections
results_with_projections <- abc_sampler$run_projections(projection_parameters)
```


```{r viz-projections, fig.width=10, fig.height=5}
library(ggplot2)
library(tidyr)

# Extract projection quantiles into an R data frame
df_proj <- results_with_projections$get_projection_quantiles(simulation_dates_projection)

# Build R data frame
df_proj_r <- data.frame(
  date = py_to_r(df_proj["date"]$values),
  quantile = py_to_r(df_proj["quantile"]$values),
  data = py_to_r(df_proj["data"]$values)
)
df_proj_r$date <- as.Date(df_proj_r$date)

# Pivot to wide format for ribbon plotting
df_proj_wide <- pivot_wider(df_proj_r, names_from = quantile, values_from = data, names_prefix = "q")

# Plot with ggplot2
ggplot() +
  # Projection ribbon + median
  geom_ribbon(data = df_proj_wide, aes(x = date, ymin = q0.05, ymax = q0.95),
              fill = "blue", alpha = 0.3) +
  geom_line(data = df_proj_wide, aes(x = date, y = q0.5, color = "Projection")) +
  # Observed data points
  geom_point(data = data_calibration, aes(x = date, y = data, shape = "Calibration data"),
             color = "black", size = 1.5) +
  geom_point(data = data_projection, aes(x = date, y = data, shape = "Held-out data"),
             color = "gray50", size = 1.5, alpha = 0.6) +
  # Calibration cutoff
  geom_vline(xintercept = as.numeric(data_calibration$date[nrow(data_calibration)]),
             color = "red", linetype = "dashed", alpha = 0.5) +
  scale_color_manual(values = c("Projection" = "blue")) +
  scale_shape_manual(values = c("Calibration data" = 16, "Held-out data" = 1)) +
  labs(x = NULL, y = "New Infections", title = "Model Calibration and Projection",
       color = NULL, shape = NULL) +
  theme_minimal() +
  theme(legend.position = "top")

plt$show()
```

---

## Resources

- [Epydemix Documentation](https://epydemix.readthedocs.io/)
- [ABC Methods Reference (Minter et al., 2019)](https://www.sciencedirect.com/science/article/pii/S175543651930026X)
- [ABC-SMC Algorithm (Toni et al., 2009)](https://pubmed.ncbi.nlm.nih.gov/19205079)
- [Reticulate Package](https://rstudio.github.io/reticulate/)
